// Copyright 2017 Intel Corporation.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"sync"
	"sync/atomic"
	"time"

	"github.com/intel-go/yanff/flow"
	"github.com/intel-go/yanff/packet"
)

// test-handle2-part1: sends packets to 0 port, receives from 0 and 1 ports.
// This part of test generates three packet flows (1st, 2nd and 3rd), merges them into one flow
// and send it to 0 port. Packets in original 1st, 2nd and 3rd flows has UDP destination addresses
// dstPort1, dstPort2, dstPort3 respectively. For each packet sender calculates
// IPv4 and UDP checksums and verify it on packet receive.
// This part of test receive packets on 0 port, expects to receive ~33% of packets.
// Test also calculates number of broken packets and prints it when a predefined number
// of packets is received.
//
// test-handle2-part2:
// This part of test receives packets on 0 port, separate input flow according to rules
// in test-separate-l3rules.conf into 2 flows. Accepted flow sent to 0 port, rejected flow is stopped.

const (
	totalPackets = 10000000

	// Test expects to receive 33% of packets on 0 port.
	// Test is PASSSED, if p1 is in [low1;high1]
	eps   = 5
	high1 = 33 + eps
	low1  = 33 - eps
)

var (
	// Payload is 16 byte md5 hash sum of headers
	payloadSize uint = 16
	d           uint = 10

	sentPacketsGroup1 uint64
	sentPacketsGroup2 uint64
	sentPacketsGroup3 uint64

	sent          uint64
	recv          uint64
	brokenPackets uint64

	dstPort1 uint16 = 111
	dstPort2 uint16 = 222
	dstPort3 uint16 = 333

	testDoneEvent *sync.Cond

	outport uint
	inport  uint
)

// CheckFatal is an error handling function
func CheckFatal(err error) {
	if err != nil {
		fmt.Printf("checkfail: %+v\n", err)
		os.Exit(1)
	}
}

func main() {
	flag.UintVar(&outport, "outport", 0, "port for sender")
	flag.UintVar(&inport, "inport", 0, "port for receiver")
	flag.Parse()

	// Init YANFF system at 16 available cores.
	config := flow.Config{
		CPUList: "0-15",
	}
	CheckFatal(flow.SystemInit(&config))

	var m sync.Mutex
	testDoneEvent = sync.NewCond(&m)

	// Create first packet flow
	outputFlow, err := flow.SetGenerator(generatePacket, 0, nil)
	CheckFatal(err)

	CheckFatal(flow.SetSender(outputFlow, uint8(outport)))

	// Create receiving flows and set a checking function for it
	inputFlow1, err := flow.SetReceiver(uint8(outport))
	CheckFatal(err)
	CheckFatal(flow.SetHandler(inputFlow1, checkInputFlow, nil))
	CheckFatal(flow.SetStopper(inputFlow1))

	// Start pipeline
	go func() {
		CheckFatal(flow.SystemStart())
	}()

	// Wait for enough packets to arrive
	testDoneEvent.L.Lock()
	testDoneEvent.Wait()
	testDoneEvent.L.Unlock()

	// Compose statistics
	sent1 := sentPacketsGroup1
	sent2 := sentPacketsGroup2
	sent3 := sentPacketsGroup3
	sent := sent1 + sent2 + sent3

	received := atomic.LoadUint64(&recv)

	var p int
	if sent != 0 {
		p = int(received * 100 / sent)
	}
	broken := atomic.LoadUint64(&brokenPackets)

	// Print report
	println("Sent", sent, "packets")
	println("Received", received, "packets")
	println("Proportion of received packets ", p, "%")
	println("Broken = ", broken, "packets")

	// Test is PASSSED, if p is ~33%
	if p <= high1 && p >= low1 {
		println("TEST PASSED")
	} else {
		println("TEST FAILED")
	}

}

func generatePacket(pkt *packet.Packet, context flow.UserContext) {
	if pkt == nil {
		log.Fatal("Failed to create new packet")
	}
	if packet.InitEmptyIPv4UDPPacket(pkt, payloadSize) == false {
		log.Fatal("Failed to init empty packet")
	}
	ipv4 := pkt.GetIPv4()
	udp := pkt.GetUDPForIPv4()
	switch sent % 3 {
	case 0:
		udp.DstPort = packet.SwapBytesUint16(dstPort1)
		sentPacketsGroup1++
	case 1:
		udp.DstPort = packet.SwapBytesUint16(dstPort2)
		sentPacketsGroup2++
	case 2:
		udp.DstPort = packet.SwapBytesUint16(dstPort3)
		sentPacketsGroup3++
	}
	sent++

	ipv4.HdrChecksum = packet.SwapBytesUint16(packet.CalculateIPv4Checksum(ipv4))
	udp.DgramCksum = packet.SwapBytesUint16(packet.CalculateIPv4UDPChecksum(ipv4, udp, pkt.Data))

	if sentPacketsGroup1 > totalPackets/3 {
		time.Sleep(time.Second * time.Duration(d))
		println("TEST FAILED")
	}
}

func checkInputFlow(pkt *packet.Packet, context flow.UserContext) {
	offset := pkt.ParseData()
	if offset < 0 {
		println("ParseData returned negative value", offset)
		// Some received packets are not generated by this example
		// They cannot be parsed due to unknown protocols, skip them
	} else {
		ipv4 := pkt.GetIPv4()
		udp := pkt.GetUDPForIPv4()
		recvIPv4Cksum := packet.SwapBytesUint16(packet.CalculateIPv4Checksum(ipv4))
		recvUDPCksum := packet.SwapBytesUint16(packet.CalculateIPv4UDPChecksum(ipv4, udp, pkt.Data))

		if recvIPv4Cksum != ipv4.HdrChecksum || recvUDPCksum != udp.DgramCksum {
			// Packet is broken
			atomic.AddUint64(&brokenPackets, 1)
			return
		}
		atomic.AddUint64(&recv, 1)
	}
	// TODO 80% of requested number of packets.
	if recv >= totalPackets/32*8 {
		testDoneEvent.Signal()
	}
}
